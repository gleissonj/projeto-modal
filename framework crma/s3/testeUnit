import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.MockedStatic;

import java.io.File;
import java.nio.file.Path;

import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;
import static org.mockito.ArgumentMatchers.*;
import static org.mockito.Mockito.*;

/**
 * Supondo que o método testado está em:
 *   public class ArquivoService { 
 *       static Logger logger = LoggerFactory.getLogger(ArquivoService.class);
 *       static boolean isUnix() { ... }
 *       public static void ajustarPermissoesPosCopia(Path destino) { ... }
 *   }
 */
class ArquivoServiceTest {

    private MockedStatic<ArquivoService> mockStaticService;
    private org.slf4j.Logger originalLogger;

    @BeforeEach
    void setUp() {
        // Força sempre o ramo NÃO-UNIX (o 'else') para estes testes
        mockStaticService = mockStatic(ArquivoService.class, CALLS_REAL_METHODS);
        mockStaticService.when(ArquivoService::isUnix).thenReturn(false);

        // Guarda logger original e injeta mock para validar mensagens
        originalLogger = ArquivoService.logger;
        ArquivoService.logger = mock(org.slf4j.Logger.class);
    }

    @AfterEach
    void tearDown() {
        if (mockStaticService != null) mockStaticService.close();
        ArquivoService.logger = originalLogger;
    }

    @Test
    void deveExecutarElseComSucesso_semGerarWarn() {
        // Arrange: Path e File mockados
        Path path = mock(Path.class);
        File file = mock(File.class);
        when(path.toFile()).thenReturn(file);

        // Simula sucesso em todas as permissões
        when(file.setReadable(true, true)).thenReturn(true);
        when(file.setWritable(true, true)).thenReturn(true);
        when(file.setExecutable(false, true)).thenReturn(true);

        // Act
        assertDoesNotThrow(() -> ArquivoService.ajustarPermissoesPosCopia(path));

        // Assert: não deve logar warn do bloco de validação
        verify(ArquivoService.logger, never())
                .warn(startsWith("Falha ao ajustar algumas permissões"));
        // Também não deve cair no catch
        verify(ArquivoService.logger, never())
                .warn(startsWith("Não foi possível ajustar permissões"));
    }

    @Test
    void deveExecutarElseEGerarWarn_quandoAlgumaPermissaoFalha() {
        // Arrange
        Path path = mock(Path.class);
        File file = mock(File.class);
        when(path.toFile()).thenReturn(file);

        // Força falha em pelo menos uma das permissões (ex.: writable = false)
        when(file.setReadable(true, true)).thenReturn(true);
        when(file.setWritable(true, true)).thenReturn(false);
        when(file.setExecutable(false, true)).thenReturn(true);

        // Act
        ArquivoService.ajustarPermissoesPosCopia(path);

        // Assert: deve gerar warn do bloco interno
        verify(ArquivoService.logger, atLeastOnce())
                .warn(startsWith("Falha ao ajustar algumas permissões do arquivo temporário"),
                        anyBoolean(), anyBoolean(), anyBoolean());

        // Não deve cair no catch
        verify(ArquivoService.logger, never())
                .warn(startsWith("Não foi possível ajustar permissões"));
    }

    @Test
    void deveCapturarExcecaoNoElse_eLogarWarnDoCatch() {
        // Arrange
        Path path = mock(Path.class);
        File file = mock(File.class);
        when(path.toFile()).thenReturn(file);

        // Lança exceção logo na primeira chamada de permissão para exercitar o catch
        when(file.setReadable(true, true)).thenThrow(new RuntimeException("boom"));

        // Act
        ArquivoService.ajustarPermissoesPosCopia(path);

        // Assert: deve logar o warn do catch
        verify(ArquivoService.logger, atLeastOnce())
                .warn(startsWith("Não foi possível ajustar permissões do arquivo temporário"),
                        contains("boom"));
    }
}
