public class MultipartFileUploader {

    public void sendFile() {
        // Caminho para o arquivo armazenado no Salesforce (aqui usando ContentVersion para exemplo)
        String fileName = 'teste.pdf';
        Blob fileContent = [SELECT VersionData FROM ContentVersion WHERE Title = :fileName LIMIT 1].VersionData;
        
        // Montar o boundary único para separar as partes do multipart/form-data
        String boundary = '----WebKitFormBoundaryCqops';

        // Montando o corpo da requisição
        String body = '--' + boundary + '\r\n';
        body += 'Content-Disposition: form-data; name="arquivo"; filename="' + fileName + '"\r\n';
        body += 'Content-Type: application-pdf\r\n\r\n';  // Content-Type do arquivo
        body += EncodingUtil.urlEncode(fileContent.toString(), 'UTF-8') + '\r\n';  // O conteúdo do arquivo em base64
        body += '--' + boundary + '--';

        // Configurar a requisição HTTP
        HttpRequest req = new HttpRequest();
        req.setEndpoint('http://localhost:8081/upload');  // URL do endpoint do MuleSoft
        req.setMethod('POST');
        req.setHeader('Content-Type', 'multipart/form-data; boundary=' + boundary);
        req.setBodyAsBlob(Blob.valueOf(body)); // Convertendo o corpo em Blob
       
        // Enviar a requisição
        Http http = new Http();
        HttpResponse res = http.send(req);

        // Log da resposta
        System.debug(res.getBody());
    }
}
//////////////////////////////////



public class JX1_documentformbuilder {
    private final static String Boundary = '-----JX1';
    
    public static String getContentType() {
        return 'multipart/form-data; charset=UTF-8; boundary=' + Boundary;
    }

    public static Blob CreateMultipartFormDataBody(JX1_FIle file) {
        Map<String, String> mapKeysValues = new Map<String, String>();

        // Preenche a map com informações adicionais
        mapKeysValues.put('sha256', file.sha256);
        mapKeysValues.put('idArquivo', file.idArquivo);
        mapKeysValues.put('idConteudo', file.idConteudo);
        
        // Criar a parte multipart com os dados do arquivo e outros parâmetros
        String multipartAttributes = '';
        if (mapKeysValues != null) {
            for (String keyValue : mapKeysValues.keySet()) {
                multipartAttributes += '--' + Boundary + '\r\n';
                multipartAttributes += 'Content-Disposition: form-data; name="' + keyValue + '"\r\n\r\n';
                multipartAttributes += mapKeysValues.get(keyValue) + '\r\n';
            }
        }

        // O arquivo já está em formato Blob, então não é necessário usar base64
        Blob blobFile = file.arquivo;  // Arquivo como Blob, não base64

        // Corpo da requisição com o arquivo binário
        String body = '--' + Boundary + '\r\n' +
                      'Content-Disposition: form-data; name="arquivo"; filename="teste.pdf"\r\n' +  // Nome do arquivo e tipo
                      'Content-Type: application/pdf\r\n\r\n';  // Tipo MIME do arquivo, pode ser "application/pdf" ou outro conforme o tipo do arquivo

        // Adicionando o arquivo binário diretamente no corpo da requisição
        body += EncodingUtil.urlEncode(blobFile.toString(), 'UTF-8');  // Convertendo para String para enviar no corpo, embora Blob seja binário

        // Adicionando os outros dados do arquivo no formato multipart
        body += '\r\n' + multipartAttributes;
        
        // Fechando o boundary
        body += '--' + Boundary + '--';

        // Convertendo o corpo para Blob antes de enviar
        Blob bodyAsBlob = Blob.valueOf(body);  // Aqui a string é convertida em Blob

        return bodyAsBlob;
    }
}




%dw 2.0
output application/json
var myData = "cGFyYWdyYXBo" // Exemplo de conteúdo Base64 (que corresponde a "paragragh")
---
if (myData matches /^[A-Za-z0-9+/=]+$/) "É Base64" else "Não é Base64"
