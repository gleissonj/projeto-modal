package br.com.itau.app.services;

import br.com.itau.app.exceptions.ArquivoNaoEncontradoException;
import org.apache.commons.lang3.SystemUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import software.amazon.awssdk.auth.credentials.DefaultCredentialsProvider;
import software.amazon.awssdk.regions.Region;
import software.amazon.awssdk.services.s3.S3Client;
import software.amazon.awssdk.services.s3.model.GetObjectRequest;
import software.amazon.awssdk.services.s3.model.NoSuchKeyException;
import software.amazon.awssdk.services.s3.model.S3Exception;

import java.io.File;
import java.io.IOException;
import java.net.URI;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.StandardCopyOption;
import java.nio.file.attribute.FileAttribute;
import java.nio.file.attribute.PosixFilePermission;
import java.nio.file.attribute.PosixFilePermissions;
import java.util.Set;

public class ArquivoService {

    private static final Logger logger = LoggerFactory.getLogger(ArquivoService.class);

    /**
     * Baixa um objeto do S3 (URI no formato s3://bucket/key)
     * e grava em arquivo temporário. Retorna o caminho absoluto.
     *
     * Requisitos:
     *  - Task Role do ECS com s3:GetObject (e kms:Decrypt se necessário).
     *  - AWS_REGION configurada no ambiente, ou ajuste o fallback.
     */
    public static String baixarArquivoParaTemp(String s3Uri) throws Exception {
        Path arquivoDestino = null;

        try {
            // -------- validar e extrair bucket/key --------
            URI uri = new URI(s3Uri);
            if (!"s3".equalsIgnoreCase(uri.getScheme())) {
                throw new ArquivoNaoEncontradoException("Somente esquema s3:// é suportado.");
            }
            String bucket = uri.getHost();
            String key = uri.getPath();
            if (bucket == null || bucket.isBlank()) {
                throw new IllegalArgumentException("URL s3 inválida: bucket ausente (ex.: s3://meu-bucket/pasta/arq.csv)");
            }
            if (key == null || key.isBlank() || "/".equals(key)) {
                throw new IllegalArgumentException("URL s3 inválida: key ausente (ex.: s3://meu-bucket/pasta/arq.csv)");
            }
            if (key.startsWith("/")) key = key.substring(1);

            // -------- nome do arquivo --------
            String nomeArquivo = key.substring(key.lastIndexOf('/') + 1);
            if (nomeArquivo.isEmpty()) {
                nomeArquivo = "arquivo_temp";
            }

            // -------- preparar destino temporário (NÃO cria o arquivo aqui) --------
            arquivoDestino = prepararDestinoTemporario(nomeArquivo);

            // -------- cria diretório pai se necessário --------
            Files.createDirectories(arquivoDestino.getParent());

            // -------- baixar via stream --------
            String regionEnv = System.getenv("AWS_REGION");
            Region region = Region.of((regionEnv != null && !regionEnv.isBlank()) ? regionEnv : "sa-east-1");

            try (S3Client s3 = S3Client.builder()
                    .region(region)
                    .credentialsProvider(DefaultCredentialsProvider.create())
                    .build()) {

                GetObjectRequest req = GetObjectRequest.builder()
                        .bucket(bucket)
                        .key(key)
                        .build();

                // stream: S3 -> arquivo local (cria/trunca automaticamente)
                try (var in = s3.getObject(req)) {
                    Files.copy(in, arquivoDestino, StandardCopyOption.REPLACE_EXISTING);
                }
            } catch (NoSuchKeyException e) {
                throw new ArquivoNaoEncontradoException("Objeto não encontrado: s3://" + bucket + "/" + key);
            } catch (S3Exception e) {
                logger.error("Erro S3 ao baixar s3://{}/{}: {} ({})",
                        bucket, key,
                        (e.awsErrorDetails() != null ? e.awsErrorDetails().errorMessage() : e.getMessage()),
                        e.statusCode());
                throw new ArquivoNaoEncontradoException("Não foi possível baixar do S3: s3://" + bucket + "/" + key);
            }

            // -------- ajustar permissões pós-cópia (coerente com sua lógica) --------
            ajustarPermissoesPosCopia(arquivoDestino);

            return arquivoDestino.toAbsolutePath().toString();

        } catch (ArquivoNaoEncontradoException e) {
            logger.error("Erro ao baixar arquivo: {}", e.getMessage());
            tentarApagar(arquivoDestino);
            throw e;

        } catch (Exception e) {
            logger.error("Erro ao processar download do S3: {}", e.getMessage());
            tentarApagar(arquivoDestino);
            throw e;
        }
    }

    // ----------------- Helpers -----------------

    /**
     * Cria apenas o diretório temporário adequado e retorna o path do arquivo
     * (sem criar o arquivo em si).
     */
    private static Path prepararDestinoTemporario(String nomeArquivo) throws IOException {
        if (SystemUtils.IS_OS_UNIX) {
            FileAttribute<Set<PosixFilePermission>> attr =
                    PosixFilePermissions.asFileAttribute(PosixFilePermissions.fromString("rwx------"));
            Path tempDir = Files.createTempDirectory("dados_crma_", attr);
            return tempDir.resolve(nomeArquivo); // arquivo ainda não existe
        } else {
            Path tempDir = Files.createTempDirectory("dados_crma_");
            return tempDir.resolve(nomeArquivo); // arquivo ainda não existe
        }
    }

    /**
     * Mantém a ideia de permissões do seu código original:
     * - Unix: 700 no arquivo final.
     * - Windows: readable/writable para o usuário (execute desnecessário).
     */
    private static void ajustarPermissoesPosCopia(Path destino) {
        try {
            if (SystemUtils.IS_OS_UNIX) {
                Files.setPosixFilePermissions(destino, PosixFilePermissions.fromString("rwx------")); // 700
            } else {
                File f = destino.toFile();
                f.setReadable(true, true);
                f.setWritable(true, true);
                f.setExecutable(false, true);
            }
        } catch (Exception e) {
            // best-effort: não falha o fluxo por causa de permissão de arquivo
            logger.warn("Não foi possível ajustar permissões do arquivo temporário: {}", e.getMessage());
        }
    }

    private static void tentarApagar(Path p) {
        if (p == null) return;
        try {
            Files.deleteIfExists(p);
            Path parent = p.getParent();
            if (parent != null) Files.deleteIfExists(parent); // remove o dir temp se vazio
        } catch (Exception ignore) {}
    }
}
