package br.com.itau.app.services;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.io.TempDir;

import java.io.File;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.logging.Handler;
import java.util.logging.Level;
import java.util.logging.LogRecord;
import java.util.logging.Logger;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

/**
 * Testa ajustarPermissoesPosCopia sem modificar a classe original.
 * Cenários:
 *  1) Sucesso no ramo else (arquivo real).
 *  2) Falha de permissão no ramo else (Path/File mockado) -> entra no if interno.
 *  3) Exceção no else -> entra no catch.
 */
class ArquivoServiceTest {

    /**
     * 1) Exercita o ELSE com arquivo real (sucesso).
     * Requer que a JVM de teste esteja com -Dos.name=Windows 10 (ver surefire/gradle).
     */
    @Test
    void else_sucesso_comArquivoReal(@TempDir Path tempDir) throws Exception {
        // Arrange: cria arquivo real
        Path destino = tempDir.resolve("arquivo.txt");
        Files.writeString(destino, "teste");

        // Act
        assertDoesNotThrow(() -> ArquivoService.ajustarPermissoesPosCopia(destino));

        // Assert (best effort): deve ter continuado OK; checamos flags comuns
        File f = destino.toFile();
        assertTrue(f.canRead(), "Esperado que o arquivo esteja legível");
        assertTrue(f.canWrite(), "Esperado que o arquivo esteja gravável");
        // Executável pode variar por FS/SO; não assertamos rigidamente
    }

    /**
     * 2) Exercita o ELSE com falha de permissão (entra no if interno).
     * Usamos Path/File mockados para controlar os retornos de setReadable/Writable/Executable.
     * Capturamos WARNING via java.util.logging para garantir que o warn foi emitido.
     */
    @Test
    void else_falhaAlgumaPermissao_geraWarningNoIfInterno() {
        // Arrange: Path e File mockados (só o ELSE usa toFile(), sem POSIX)
        Path path = mock(Path.class);
        File file = mock(File.class);
        when(path.toFile()).thenReturn(file);

        // Simula falha em uma permissão (writable = false)
        when(file.setReadable(true, true)).thenReturn(true);
        when(file.setWritable(true, true)).thenReturn(false);
        when(file.setExecutable(false, true)).thenReturn(true);

        // Captura logs WARNING do logger da classe (JUL)
        Logger classLogger = Logger.getLogger(ArquivoService.class.getName());
        TestLogHandler handler = new TestLogHandler();
        Level oldLevel = classLogger.getLevel();
        boolean oldUseParent = classLogger.getUseParentHandlers();
        classLogger.setLevel(Level.ALL);
        classLogger.setUseParentHandlers(false); // evita poluir saída do runner
        classLogger.addHandler(handler);

        try {
            // Act
            ArquivoService.ajustarPermissoesPosCopia(path);
        } finally {
            // Cleanup handler
            classLogger.removeHandler(handler);
            classLogger.setUseParentHandlers(oldUseParent);
            classLogger.setLevel(oldLevel);
        }

        // Assert: deve ter gerado um WARNING com a mensagem esperada
        assertTrue(
            handler.hasWarningStartingWith("Falha ao ajustar algumas permissões do arquivo temporário"),
            "Esperado WARNING sobre falha de permissões no bloco interno"
        );

        // Também valida que tentamos ajustar todas as permissões
        verify(file).setReadable(true, true);
        verify(file).setWritable(true, true);
        verify(file).setExecutable(false, true);
    }

    /**
     * 3) Exercita o catch: provocamos exceção dentro do ELSE.
     * Usamos Path/File mockados e lançamos RuntimeException no primeiro setReadable.
     * Capturamos WARNING do catch.
     */
    @Test
    void else_excecaoCapturada_noCatchGeraWarning() {
        Path path = mock(Path.class);
        File file = mock(File.class);
        when(path.toFile()).thenReturn(file);

        // Lança exceção na primeira chamada para cair no catch
        when(file.setReadable(true, true)).thenThrow(new RuntimeException("boom"));

        Logger classLogger = Logger.getLogger(ArquivoService.class.getName());
        TestLogHandler handler = new TestLogHandler();
        Level oldLevel = classLogger.getLevel();
        boolean oldUseParent = classLogger.getUseParentHandlers();
        classLogger.setLevel(Level.ALL);
        classLogger.setUseParentHandlers(false);
        classLogger.addHandler(handler);

        try {
            assertDoesNotThrow(() -> ArquivoService.ajustarPermissoesPosCopia(path));
        } finally {
            classLogger.removeHandler(handler);
            classLogger.setUseParentHandlers(oldUseParent);
            classLogger.setLevel(oldLevel);
        }

        assertTrue(
            handler.hasWarningStartingWith("Não foi possível ajustar permissões do arquivo temporário"),
            "Esperado WARNING vindo do catch"
        );

        verify(file).setReadable(true, true);
        // writable/executable podem não ser chamados por causa da exceção – não verificamos
    }

    /** Handler simples para capturar WARNINGs de JUL. */
    static class TestLogHandler extends Handler {
        private final StringBuilder warnings = new StringBuilder();

        @Override
        public void publish(LogRecord record) {
            if (record.getLevel().intValue() >= Level.WARNING.intValue()) {
                if (record.getMessage() != null) {
                    warnings.append(record.getMessage()).append('\n');
                }
            }
        }
        @Override public void flush() {}
        @Override public void close() throws SecurityException {}

        boolean hasWarningStartingWith(String prefix) {
            return warnings.toString().lines().anyMatch(l -> l.startsWith(prefix));
        }
    }
}
