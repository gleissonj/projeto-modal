Duvidas: 

- auntenticacao, toke, escopo
- a url pre assinada expira em 15 segundos se o file for mto grande vai dar tempo?
- o ecs ele fica de pé passando na fila pra pegar e ver se tem mensagem. Com isso onde inicia ai no codigo o ECS , onde é o ponta a pé? é no service? 
- onde ele faz o depara dos metadados para o dataset? tem isso aq ou ele só sobe la pra sales e a sales faz o resto?
- onde q ele faz a quebra do arquivo em partes de 32mb?
- onde é feito o download dos arquivos 
- voce consegue debugar ai me mostrando como ele pega a mensagem da fila e faz todo o procedimento até a subida pra salesforce pro crma
- onde ele faz a validacao desses dados do json que publica na fila?
- no sql service tem a linha 96 e 97 ta certo ficar desse jeito 
- dar um pull na develop
- se tiver 20 files de 32 mb ele armazena os 20 temporarios?
- pedir curl da chamada insomina
- Saber como a API funciona tecnicamente: do início (mensagem na SQS) até o fim (envio ao Salesforce).

PROBLEMAS:
- nao consegui bater o erro publicando na fila pra aparecer no datadog

FAZER :
- dar um pull na develop



DAILY

- ajuda com time de contatos com a integração de contatos eles precisam desativar um fluxo
- na quarta e ontem estava boa parte dando um help para o time do Edgar 
- ontem tbm o time do Minoto, me ligou pra ve sobre um limite de um gtw q eles tavam tomando , não tive o erro , mas consegui achar 
  uma doc e um cara aq q teve o msm problema e com a solução
- tbm tava com o time da ntt realizando o deploy dos códigos do agente , tivemos alguns erros mas ai o Thiago tbm deu uma ajuda boa pra gente
- na quarta não consegui falar com o Pedrao sobre o repasse do framework, ele agarrou em outras agendas q não conseguimos falar, ontem tivemos uma agenda, ele começou a me dar um overview, estou marcando uma recorrência diária com ele
- conforme eu to falando com ele já estou escrevendo os fluxos conforme ele vai me passando para posteriormente documentar o framework
- ontem tbm tive uma agenda com o Rempto, ele tava querendo saber sobre as migrações das apis do mule para a aws e digibee
- hoje tenho reunião com o Pedrao
- vou ta debrucçando tbm nos códigos pra entender o funcionamento, e configurar minha maquina pra rodar localmente 
- Thiago pedi o grupo do sa7 mas fomos rejeitados 



na sexta, estava configurando a maquina pra rodar local o projeto do framweork 
já estou conseguindo rodar o projeto, porem qdo ele tenta conectar na salesforce estou tomando um erro de certificado pela IDE
tbm na sexta estava debugando o código pra ir entendendo o funcionamento

sexta dei suporte para dois membros la do time do Edgar 
hoje vou ta olhando essa questão do erro de certificado q estou tendo na execução do framework
vou ta ajudando o rapaz do time do Edgar a configurar o ambiente dele pq , na semana q ia ajudar ele precisou parar pra dar continuidade em outra demanda e ai não chegamos a finalizar a configuração na maquina dele 

tbm do framwrokd, acho q o email não ta sendo disparado caso de algum erro no ececuacao da carga, então vou ta desenvolvendo essa parte do envio do email caso de alguma falha e posteriormente já ir criando a documentação do framework





import javax.net.ssl.*;
import java.security.cert.X509Certificate;
import java.security.SecureRandom;

@SpringBootApplication
public class MicroserviceApplication {

    public static void main(String[] args) {
        // ⚠️ Somente para AMBIENTE DE TESTES!
        try {
            disableSslVerification();
        } catch (Exception e) {
            e.printStackTrace();
        }

        SpringApplication.run(MicroserviceApplication.class, args);
    }

    private static void disableSslVerification() throws Exception {
        TrustManager[] trustAllCerts = new TrustManager[]{
            new X509TrustManager() {
                public void checkClientTrusted(X509Certificate[] certs, String authType) {}
                public void checkServerTrusted(X509Certificate[] certs, String authType) {}
                public X509Certificate[] getAcceptedIssuers() { return new X509Certificate[0]; }
            }
        };

        SSLContext sc = SSLContext.getInstance("TLS");
        sc.init(null, trustAllCerts, new SecureRandom());
        HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());

        // Ignora verificação de hostname
        HttpsURLConnection.setDefaultHostnameVerifier((hostname, session) -> true);
    }
}




import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

import javax.net.ssl.HttpsURLConnection;
import javax.net.ssl.SSLContext;
import javax.net.ssl.TrustManager;
import javax.net.ssl.X509TrustManager;
import java.security.SecureRandom;
import java.security.cert.X509Certificate;

@SpringBootApplication
public class MicroserviceApplication {

    public static void main(String[] args) {
        try {
            disableSslVerification(); // ⚠️ apenas para DEV
        } catch (Exception e) {
            e.printStackTrace();
        }

        SpringApplication.run(MicroserviceApplication.class, args);
    }

    private static void disableSslVerification() throws Exception {
        TrustManager[] trustAllCerts = new TrustManager[]{
            new X509TrustManager() {
                public void checkClientTrusted(X509Certificate[] certs, String authType) {}
                public void checkServerTrusted(X509Certificate[] certs, String authType) {}
                public X509Certificate[] getAcceptedIssuers() {
                    return new X509Certificate[0];
                }
            }
        };

        SSLContext sc = SSLContext.getInstance("TLS");
        sc.init(null, trustAllCerts, new SecureRandom());
        HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());

        // Ignora validação de hostname
        HttpsURLConnection.setDefaultHostnameVerifier((hostname, session) -> true);
    }
}



keytool -import -alias aws-cert -keystore "$JAVA_HOME/lib/security/cacerts" -file aws.crt



-Djavax.net.ssl.trustStore=C:/Users/Public/java/jdk-21/lib/security/cacerts
-Djavax.net.ssl.trustStorePassword=changeit




import io.opentelemetry.instrumentation.logging.jul.OpenTelemetryLogRecordExporter;

public class MicroserviceApplication {
    public static void main(String[] args) {
        // Inicializa o bridge do java.util.logging para OpenTelemetry
        OpenTelemetryLogRecordExporter.install();

        SpringApplication.run(MicroserviceApplication.class, args);
    }
}



<properties>
  <opentelemetry.version>1.39.0</opentelemetry.version>
</properties>

<dependencies>
  <!-- API principal do OpenTelemetry -->
  <dependency>
    <groupId>io.opentelemetry</groupId>
    <artifactId>opentelemetry-api</artifactId>
    <version>${opentelemetry.version}</version>
  </dependency>

  <!-- SDK para exportar spans -->
  <dependency>
    <groupId>io.opentelemetry</groupId>
    <artifactId>opentelemetry-sdk</artifactId>
    <version>${opentelemetry.version}</version>
  </dependency>

  <!-- Bridge para java.util.logging -->
  <dependency>
    <groupId>io.opentelemetry.instrumentation</groupId>
    <artifactId>opentelemetry-jul</artifactId>
    <version>${opentelemetry.version}</version>
  </dependency>
</dependencies>



mvn clean install -Dmaven.repo.remote=https://repo.maven.apache.org/maven2
