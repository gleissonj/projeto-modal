else {
                // No Windows, cria o arquivo tempor√°rio diretamente
                File tempFile = Files.createTempFile("dados_crma_", "_" + nomeArquivo).toFile();

                boolean leitura = tempFile.setReadable(true, true);
                boolean escrita = tempFile.setWritable(true, true);
                boolean execucao = tempFile.setExecutable(true, true);

                if (!leitura || !escrita || !execucao) {
                    throw new Exception("N√£o foi poss√≠vel definir as permiss√µes do arquivo tempor√°rio.");
                }

                arquivoDestino = tempFile.toPath();
				
				
				
TESTES




import br.com.itau.app.services.ArquivoService;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.MockedStatic;
import org.mockito.junit.jupiter.MockitoExtension;

import java.io.File;
import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
class ArquivoServiceWindowsPermissoesTest {

    @Test
    void deveLancarExcecaoQuandoNaoConseguirDefinirPermissoesNoWindows() throws Exception {
        // --- For√ßa ambiente "Windows" ANTES de qualquer refer√™ncia ao SystemUtils ---
        // (SystemUtils calcula flags na carga da classe com base em os.name)
        System.setProperty("os.name", "Windows 10");

        // URL qualquer (n√£o ser√° usada porque vamos falhar nas permiss√µes antes do download)
        String nome = URLEncoder.encode("arquivo.zip", StandardCharsets.UTF_8);
        String url = "http://exemplo.com/" + nome;

        // Mocka Files.createTempFile(...) para devolver um Path cujo toFile() √© um File mockado
        Path pathMock = mock(Path.class);
        File fileMock = mock(File.class);

        // toFile() retorna nosso File mockado
        when(pathMock.toFile()).thenReturn(fileMock);

        // Os 3 setters de permiss√£o retornam "false" para simular falha
        when(fileMock.setReadable(true, true)).thenReturn(false);
        when(fileMock.setWritable(true, true)).thenReturn(false);
        when(fileMock.setExecutable(true, true)).thenReturn(false);

        try (MockedStatic<Files> filesStatic = mockStatic(Files.class)) {
            // Intercepta a chamada espec√≠fica do bloco do Windows:
            // Files.createTempFile("dados_crma_", "_" + nomeArquivo)
            filesStatic.when(() -> Files.createTempFile(any(String.class), any(String.class)))
                       .thenReturn(pathMock);

            // N√£o precisamos mockar Files.copy etc. porque a exce√ß√£o acontece antes

            Exception ex = assertThrows(Exception.class,
                    () -> ArquivoService.baixarArquivoParaTemp(url));

            assertTrue(ex.getMessage().contains("N√£o foi poss√≠vel definir as permiss√µes do arquivo tempor√°rio."));
        }
    }
}






@Test
void devePassarPelasPermissoesNoWindowsEUsarEsquemaFile() throws Exception {
    System.setProperty("os.name", "Windows 10");

    // Cria um arquivo real de origem para esquema file://
    Path origem = Files.createTempFile("origem_", ".dat");
    Files.writeString(origem, "conteudo");

    String uriFile = origem.toUri().toString(); // file://...

    Path pathDestinoMock = mock(Path.class);
    File fileDestinoMock = mock(File.class);

    when(pathDestinoMock.toFile()).thenReturn(fileDestinoMock);
    when(fileDestinoMock.setReadable(true, true)).thenReturn(true);
    when(fileDestinoMock.setWritable(true, true)).thenReturn(true);
    when(fileDestinoMock.setExecutable(true, true)).thenReturn(true);

    try (MockedStatic<Files> filesStatic = mockStatic(Files.class)) {
        filesStatic.when(() -> Files.createTempFile(any(String.class), any(String.class)))
                   .thenReturn(pathDestinoMock);

        // Precisaremos tamb√©m mockar Files.copy(origem, destino, ...)
        filesStatic.when(() -> Files.copy(any(java.nio.file.Path.class), any(java.nio.file.Path.class), any()))
                   .thenReturn(0L);

        // E como o seu m√©todo usa Path.resolve/createFile no UNIX apenas, no Windows ele s√≥ chama toPath():
        when(pathDestinoMock.toAbsolutePath()).thenReturn(pathDestinoMock);
        when(pathDestinoMock.toString()).thenReturn("C:\\temp\\dados_crma_algumarquivo");

        String retorno = ArquivoService.baixarArquivoParaTemp(uriFile);
        assertNotNull(retorno);
        assertTrue(retorno.contains("dados_crma_")); // ou a asser√ß√£o que preferir
    }
}

.
.
-------------------------------


import br.com.itau.app.services.ArquivoService;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.MockedStatic;
import org.mockito.junit.jupiter.MockitoExtension;

import java.io.File;
import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Answers.CALLS_REAL_METHODS;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
class ArquivoServiceWindowsPermissoesTest {

    @Test
    void deveLancarExcecaoQuandoNaoConseguirDefinirPermissoesNoWindows() throws Exception {
        String originalOs = System.getProperty("os.name");
        System.setProperty("os.name", "Windows 10"); // for√ßa caminho do Windows

        try {
            String nome = URLEncoder.encode("arquivo.zip", StandardCharsets.UTF_8);
            String url = "http://exemplo.com/" + nome;

            // Path e File mockados (somente o necess√°rio)
            Path pathMock = mock(Path.class);
            File fileMock = mock(File.class);

            when(pathMock.toFile()).thenReturn(fileMock);
            when(fileMock.setReadable(true, true)).thenReturn(false);
            when(fileMock.setWritable(true, true)).thenReturn(false);
            when(fileMock.setExecutable(true, true)).thenReturn(false);

            // IMPORTANTE: CALLS_REAL_METHODS evita quebrar outras chamadas a Files.*
            try (MockedStatic<Files> filesStatic = mockStatic(Files.class, CALLS_REAL_METHODS)) {
                filesStatic.when(() -> Files.createTempFile(any(String.class), any(String.class)))
                           .thenReturn(pathMock);

                Exception ex = assertThrows(Exception.class,
                        () -> ArquivoService.baixarArquivoParaTemp(url));

                assertTrue(ex.getMessage().contains("N√£o foi poss√≠vel definir as permiss√µes do arquivo tempor√°rio."));
            }
        } finally {
            // restaura o os.name para n√£o afetar outros testes
            if (originalOs != null) System.setProperty("os.name", originalOs);
            else System.clearProperty("os.name");
        }
    }
}

.
-------------------------



@Test
    void devePassarPelasPermissoesNoWindowsEUsarEsquemaFile() throws Exception {
        String originalOs = System.getProperty("os.name");
        System.setProperty("os.name", "Windows 10"); // for√ßa o bloco do Windows

        try {
            // Origem real (file://) para n√£o precisar mockar rede
            Path origem = Files.createTempFile("origem_", ".dat");
            Files.writeString(origem, "conteudo");
            String uriFile = origem.toUri().toString(); // file://...

            // Destino mockado (para interceptar permiss√µes e retorno)
            Path pathDestinoMock = mock(Path.class);
            File fileDestinoMock = mock(File.class);

            when(pathDestinoMock.toFile()).thenReturn(fileDestinoMock);
            when(pathDestinoMock.toAbsolutePath()).thenReturn(pathDestinoMock);
            when(pathDestinoMock.toString()).thenReturn("C:\\temp\\dados_crma_algumarquivo");

            // Permiss√µes OK
            when(fileDestinoMock.setReadable(true, true)).thenReturn(true);
            when(fileDestinoMock.setWritable(true, true)).thenReturn(true);
            when(fileDestinoMock.setExecutable(true, true)).thenReturn(true);

            // Mock est√°tico com chamadas reais por padr√£o
            try (MockedStatic<Files> filesStatic = mockStatic(Files.class, CALLS_REAL_METHODS)) {
                // S√≥ o que precisamos mudar:
                filesStatic.when(() -> Files.createTempFile(any(String.class), any(String.class)))
                           .thenReturn(pathDestinoMock);

                filesStatic.when(() -> Files.copy(any(java.nio.file.Path.class),
                                                  any(java.nio.file.Path.class),
                                                  any()))
                           .thenReturn(0L);

                String retorno = ArquivoService.baixarArquivoParaTemp(uriFile);

                assertNotNull(retorno);
                assertTrue(retorno.contains("dados_crma_"));
            }
        } finally {
            if (originalOs != null) System.setProperty("os.name", originalOs);
            else System.clearProperty("os.name");
        }
    }





    ---------------------




    package br.com.itau.app.services;

import org.junit.jupiter.api.*;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.MockedStatic;
import org.mockito.Mockito;
import org.mockito.junit.jupiter.MockitoExtension;

import java.io.File;
import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.nio.file.CopyOption;
import java.nio.file.Files;
import java.nio.file.Path;

import static org.junit.jupiter.api.Assertions.*;
import static org.junit.jupiter.api.Assumptions.assumeTrue;
import static org.mockito.Answers.CALLS_REAL_METHODS;
import static org.mockito.ArgumentMatchers.*;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
class ArquivoServiceWindowsTest {

    private String originalOs;

    @BeforeEach
    void setUp() {
        // For√ßa ambiente "Windows" para cair no bloco do Windows
        originalOs = System.getProperty("os.name");
        System.setProperty("os.name", "Windows 10");

        // Garante que o branch Windows ser√° escolhido; se SystemUtils j√° carregou como UNIX, pula o teste
        assumeTrue(!org.apache.commons.lang3.SystemUtils.IS_OS_UNIX,
                "Este teste cobre o branch Windows; se SystemUtils j√° foi inicializado como UNIX, rode isolado.");
    }

    @AfterEach
    void tearDown() {
        if (originalOs != null) System.setProperty("os.name", originalOs);
        else System.clearProperty("os.name");
    }

    @Test
    void deveLancarExcecaoQuandoNaoConseguirDefinirPermissoesNoWindows() throws Exception {
        // Prepara destino mockado (o m√©todo gera o arquivo temp e tenta setar permiss√µes nele)
        Path pathDestinoMock = mock(Path.class);
        File fileDestinoMock = mock(File.class);

        when(pathDestinoMock.toFile()).thenReturn(fileDestinoMock);

        // For√ßa falha nas 3 permiss√µes
        when(fileDestinoMock.setReadable(true, true)).thenReturn(false);
        when(fileDestinoMock.setWritable(true, true)).thenReturn(false);
        when(fileDestinoMock.setExecutable(true, true)).thenReturn(false);

        // Mock est√°tico do Files com chamadas reais por padr√£o
        try (MockedStatic<Files> filesStatic = mockStatic(Files.class, CALLS_REAL_METHODS)) {
            // Intercepta apenas a cria√ß√£o do arquivo temp no bloco do Windows
            filesStatic.when(() -> Files.createTempFile(any(String.class), any(String.class)))
                       .thenReturn(pathDestinoMock);

            // URL qualquer; exce√ß√£o ocorre antes de copiar/baixar
            String nome = URLEncoder.encode("arquivo.zip", StandardCharsets.UTF_8);
            String url = "http://exemplo.com/" + nome;

            Exception ex = assertThrows(Exception.class,
                    () -> ArquivoService.baixarArquivoParaTemp(url));

            assertTrue(ex.getMessage().contains("N√£o foi poss√≠vel definir as permiss√µes do arquivo tempor√°rio."));
        }
    }

    @Test
    void devePassarPelasPermissoesNoWindowsEUsarEsquemaFile() throws Exception {
        // Cria origem real (file://) para evitar network mocking
        Path origem = Files.createTempFile("origem_", ".dat");
        Files.writeString(origem, "conteudo");
        String uriFile = origem.toUri().toString(); // file://...

        // Prepara destino mockado
        Path pathDestinoMock = mock(Path.class);
        File fileDestinoMock = mock(File.class);

        when(pathDestinoMock.toFile()).thenReturn(fileDestinoMock);
        when(pathDestinoMock.toAbsolutePath()).thenReturn(pathDestinoMock);
        when(pathDestinoMock.toString()).thenReturn("C:\\temp\\dados_crma_algumarquivo");

        // Permiss√µes OK
        when(fileDestinoMock.setReadable(true, true)).thenReturn(true);
        when(fileDestinoMock.setWritable(true, true)).thenReturn(true);
        when(fileDestinoMock.setExecutable(true, true)).thenReturn(true);

        try (MockedStatic<Files> filesStatic = mockStatic(Files.class, CALLS_REAL_METHODS)) {
            // Intercepta apenas a cria√ß√£o do arquivo temp
            filesStatic.when(() -> Files.createTempFile(any(String.class), any(String.class)))
                       .thenReturn(pathDestinoMock);

            // ‚úÖ Stub correto: Path ‚Üí Path retorna o pr√≥prio destino (argumento 1)
            filesStatic.when(() -> Files.copy(
                    any(Path.class),
                    any(Path.class),
                    Mockito.<CopyOption[]>any()
            )).thenAnswer(inv -> inv.getArgument(1, Path.class));

            String retorno = ArquivoService.baixarArquivoParaTemp(uriFile);

            assertNotNull(retorno);
            assertTrue(retorno.contains("dados_crma_"));
        }
    }
}



-----------------------



package br.com.itau.app.services;

import org.junit.jupiter.api.*;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.MockedStatic;
import org.mockito.Mockito;
import org.mockito.junit.jupiter.MockitoExtension;

import java.io.File;
import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.nio.file.CopyOption;
import java.nio.file.Files;
import java.nio.file.Path;

import static org.junit.jupiter.api.Assertions.*;
import static org.junit.jupiter.api.Assumptions.assumeTrue;
import static org.mockito.Answers.CALLS_REAL_METHODS;
import static org.mockito.ArgumentMatchers.*;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
class ArquivoServiceWindowsTest {

    private String originalOs;

    @BeforeEach
    void setUp() {
        originalOs = System.getProperty("os.name");
        System.setProperty("os.name", "Windows 10"); // for√ßa o branch do Windows
        // Se a su√≠te j√° inicializou o SystemUtils como UNIX, pula estes testes
        assumeTrue(!org.apache.commons.lang3.SystemUtils.IS_OS_UNIX,
                "Branch Windows: rode isolado se SystemUtils j√° foi inicializado como UNIX.");
    }

    @AfterEach
    void tearDown() {
        if (originalOs != null) System.setProperty("os.name", originalOs);
        else System.clearProperty("os.name");
    }

    @Test
    void deveLancarExcecaoQuandoNaoConseguirDefinirPermissoesNoWindows() throws Exception {
        Path pathDestinoMock = mock(Path.class);
        File fileDestinoMock = mock(File.class);

        when(pathDestinoMock.toFile()).thenReturn(fileDestinoMock);

        // ‚õî for√ßa falha nas permiss√µes
        when(fileDestinoMock.setReadable(true, true)).thenReturn(false);
        when(fileDestinoMock.setWritable(true, true)).thenReturn(false);
        when(fileDestinoMock.setExecutable(true, true)).thenReturn(false);

        try (MockedStatic<Files> filesStatic = mockStatic(Files.class, CALLS_REAL_METHODS)) {
            filesStatic.when(() -> Files.createTempFile(any(String.class), any(String.class)))
                       .thenReturn(pathDestinoMock);

            String nome = URLEncoder.encode("arquivo.zip", StandardCharsets.UTF_8);
            String url = "http://exemplo.com/" + nome;

            Exception ex = assertThrows(Exception.class,
                    () -> ArquivoService.baixarArquivoParaTemp(url));

            assertTrue(ex.getMessage().contains("N√£o foi poss√≠vel definir as permiss√µes do arquivo tempor√°rio."));
        }
    }

    @Test
    void devePassarPelasPermissoesNoWindowsEUsarEsquemaFile() throws Exception {
        // Origem real (file://) ‚Äî evita mock de rede
        Path origem = Files.createTempFile("origem_", ".dat");
        Files.writeString(origem, "conteudo");
        String uriFile = origem.toUri().toString(); // file://...

        // Destino mockado
        Path pathDestinoMock = mock(Path.class);
        File fileDestinoMock = mock(File.class);

        when(pathDestinoMock.toFile()).thenReturn(fileDestinoMock);
        when(pathDestinoMock.toAbsolutePath()).thenReturn(pathDestinoMock);
        when(pathDestinoMock.toString()).thenReturn("C:\\temp\\dados_crma_algumarquivo");

        // ‚úÖ permiss√µes OK
        when(fileDestinoMock.setReadable(true, true)).thenReturn(true);
        when(fileDestinoMock.setWritable(true, true)).thenReturn(true);
        when(fileDestinoMock.setExecutable(true, true)).thenReturn(true);

        // üîß **ESSENCIAL**: o File mockado deve devolver um Path n√£o-nulo
        when(fileDestinoMock.toPath()).thenReturn(pathDestinoMock);

        try (MockedStatic<Files> filesStatic = mockStatic(Files.class, CALLS_REAL_METHODS)) {
            // intercepta a cria√ß√£o do temp no bloco Windows
            filesStatic.when(() -> Files.createTempFile(any(String.class), any(String.class)))
                       .thenReturn(pathDestinoMock);

            // Stub correto para a sobrecarga Path‚ÜíPath: retorna o target
            filesStatic.when(() -> Files.copy(
                    any(Path.class),
                    any(Path.class),
                    Mockito.<CopyOption[]>any()
            )).thenAnswer(inv -> inv.getArgument(1, Path.class));

            String retorno = ArquivoService.baixarArquivoParaTemp(uriFile);

            assertNotNull(retorno);
            assertTrue(retorno.contains("dados_crma_"));
        }
    }
}

-------



package br.com.itau.app.services;

import org.junit.jupiter.api.*;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.MockedStatic;
import org.mockito.Mockito;
import org.mockito.junit.jupiter.MockitoExtension;

import java.io.File;
import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.nio.file.CopyOption;
import java.nio.file.Files;
import java.nio.file.Path;

import static org.junit.jupiter.api.Assertions.*;
import static org.junit.jupiter.api.Assumptions.assumeTrue;
import static org.mockito.Answers.CALLS_REAL_METHODS;
import static org.mockito.ArgumentMatchers.*;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
class ArquivoServiceWindowsTest {

    private String originalOs;

    @BeforeEach
    void setUp() {
        originalOs = System.getProperty("os.name");
        System.setProperty("os.name", "Windows 10"); // for√ßa o branch do Windows
        // Se a su√≠te j√° inicializou o SystemUtils como UNIX, pula estes testes
        assumeTrue(!org.apache.commons.lang3.SystemUtils.IS_OS_UNIX,
                "Branch Windows: rode isolado se SystemUtils j√° foi inicializado como UNIX.");
    }

    @AfterEach
    void tearDown() {
        if (originalOs != null) System.setProperty("os.name", originalOs);
        else System.clearProperty("os.name");
    }

    @Test
    void deveLancarExcecaoQuandoNaoConseguirDefinirPermissoesNoWindows() throws Exception {
        Path pathDestinoMock = mock(Path.class);
        File fileDestinoMock = mock(File.class);

        when(pathDestinoMock.toFile()).thenReturn(fileDestinoMock);

        // ‚õî for√ßa falha nas permiss√µes
        when(fileDestinoMock.setReadable(true, true)).thenReturn(false);
        when(fileDestinoMock.setWritable(true, true)).thenReturn(false);
        when(fileDestinoMock.setExecutable(true, true)).thenReturn(false);

        try (MockedStatic<Files> filesStatic = mockStatic(Files.class, CALLS_REAL_METHODS)) {
            filesStatic.when(() -> Files.createTempFile(any(String.class), any(String.class)))
                       .thenReturn(pathDestinoMock);

            String nome = URLEncoder.encode("arquivo.zip", StandardCharsets.UTF_8);
            String url = "http://exemplo.com/" + nome;

            Exception ex = assertThrows(Exception.class,
                    () -> ArquivoService.baixarArquivoParaTemp(url));

            assertTrue(ex.getMessage().contains("N√£o foi poss√≠vel definir as permiss√µes do arquivo tempor√°rio."));
        }
    }

    @Test
    void devePassarPelasPermissoesNoWindowsEUsarEsquemaFile() throws Exception {
        // Origem real (file://) ‚Äî evita mock de rede
        Path origem = Files.createTempFile("origem_", ".dat");
        Files.writeString(origem, "conteudo");
        String uriFile = origem.toUri().toString(); // file://...

        // Destino mockado
        Path pathDestinoMock = mock(Path.class);
        File fileDestinoMock = mock(File.class);

        when(pathDestinoMock.toFile()).thenReturn(fileDestinoMock);
        when(pathDestinoMock.toAbsolutePath()).thenReturn(pathDestinoMock);
        when(pathDestinoMock.toString()).thenReturn("C:\\temp\\dados_crma_algumarquivo");

        // ‚úÖ permiss√µes OK
        when(fileDestinoMock.setReadable(true, true)).thenReturn(true);
        when(fileDestinoMock.setWritable(true, true)).thenReturn(true);
        when(fileDestinoMock.setExecutable(true, true)).thenReturn(true);

        // üîß **ESSENCIAL**: o File mockado deve devolver um Path n√£o-nulo
        when(fileDestinoMock.toPath()).thenReturn(pathDestinoMock);

        try (MockedStatic<Files> filesStatic = mockStatic(Files.class, CALLS_REAL_METHODS)) {
            // intercepta a cria√ß√£o do temp no bloco Windows
            filesStatic.when(() -> Files.createTempFile(any(String.class), any(String.class)))
                       .thenReturn(pathDestinoMock);

            // Stub correto para a sobrecarga Path‚ÜíPath: retorna o target
            filesStatic.when(() -> Files.copy(
                    any(Path.class),
                    any(Path.class),
                    Mockito.<CopyOption[]>any()
            )).thenAnswer(inv -> inv.getArgument(1, Path.class));

            String retorno = ArquivoService.baixarArquivoParaTemp(uriFile);

            assertNotNull(retorno);
            assertTrue(retorno.contains("dados_crma_"));
        }
    }
}
