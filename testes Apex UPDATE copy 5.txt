it('should download and delete files successfully', async () => {
  // Atribui o valor 'EV1' à selectValue
  component.selectValue = 'EV1';  // Defina 'EV1' para o teste simular o caminho correto

  // Verifique se environment.fileEV1 está configurado corretamente
  const prefix = environment.fileEV1;

  // Simulando a resposta de loadFiles com dois arquivos
  s3ServiceMock.listFiles.mockReturnValue(of(['file1.txt', 'file2.txt']));

  // Simulando a resposta de downloadFile com um Blob
  const mockBlob = new Blob(['file content'], { type: 'text/plain' });
  s3ServiceMock.downloadFile.mockReturnValue(of(mockBlob));

  // Simulando a resposta de deleteFile com sucesso
  s3ServiceMock.deleteFile.mockReturnValue(of(null));

  // Mockando createObjectURL
  const createObjectURLMock = jest.fn().mockReturnValue('mockedUrl');
  global.URL.createObjectURL = createObjectURLMock;

  // Executando o método
  await component.downloadFileMigration();

  // Verificando se a função listFiles foi chamada com o bucket e prefixo corretos
  expect(s3ServiceMock.listFiles).toHaveBeenCalledWith(environment.bucket, prefix);

  // Verificando se downloadFile foi chamado para cada arquivo
  expect(s3ServiceMock.downloadFile).toHaveBeenCalledWith(environment.bucket, 'file1.txt');
  expect(s3ServiceMock.downloadFile).toHaveBeenCalledWith(environment.bucket, 'file2.txt');

  // Verificando se createObjectURL foi chamado corretamente para cada arquivo
  expect(createObjectURLMock).toHaveBeenCalledTimes(2);  // Deveria ser chamado duas vezes (para cada arquivo)

  // Verificando se deleteFile foi chamado para cada arquivo após o download
  expect(s3ServiceMock.deleteFile).toHaveBeenCalledWith(environment.bucket, 'file1.txt');
  expect(s3ServiceMock.deleteFile).toHaveBeenCalledWith(environment.bucket, 'file2.txt');
});
