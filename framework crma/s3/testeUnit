package br.com.itau.app.services;

import org.apache.commons.lang3.SystemUtils;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.condition.DisabledIfSystemProperty;
import org.junit.jupiter.api.io.TempDir;

import java.io.File;
import java.nio.file.Files;
import java.nio.file.Path;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

/**
 * Testes que forçam o ramo 'else' sem alterar a classe sob teste.
 * Observação: garantimos setar 'os.name' ANTES de inicializar SystemUtils.
 */
public class ArquivoServiceElseOnlyTest {

    @BeforeAll
    static void forceNonUnixInThisJvm() throws Exception {
        // 1) Define o SO "Windows" nesta JVM de testes
        System.setProperty("os.name", "Windows 10");

        // 2) Garante que SystemUtils será inicializada só agora, já com o os.name novo
        Class.forName("org.apache.commons.lang3.SystemUtils");

        // 3) Se por algum motivo já estava carregada antes (outro teste), avisamos no log do teste
        //    e deixamos a assertion para o próprio teste decidir (assumption).
    }

    @Test
    void else_sucesso_comArquivoReal(@TempDir Path tempDir) throws Exception {
        // Se por algum motivo IS_OS_UNIX for true (classe já carregada antes), este teste não vale
        org.junit.jupiter.api.Assumptions.assumeFalse(SystemUtils.IS_OS_UNIX,
                "SystemUtils já foi inicializada como UNIX em outra parte da suíte; " +
                "rode este teste em JVM isolada ou sem reuso de forks para cobrir o else.");

        Path destino = tempDir.resolve("arquivo.txt");
        Files.writeString(destino, "teste");

        assertDoesNotThrow(() -> ArquivoService.ajustarPermissoesPosCopia(destino));

        File f = destino.toFile();
        assertTrue(f.canRead(),  "Esperado que o arquivo esteja legível");
        assertTrue(f.canWrite(), "Esperado que o arquivo esteja gravável");
        // Executável varia entre FS/SO, então não assertamos rigidamente
    }

    @Test
    void else_falhaAlgumaPermissao_entraNoIfInterno() {
        org.junit.jupiter.api.Assumptions.assumeFalse(SystemUtils.IS_OS_UNIX);

        // Usamos mock de Path/File (no else só chamamos toFile(), não tocamos em POSIX)
        Path path = mock(Path.class);
        File file = mock(File.class);
        when(path.toFile()).thenReturn(file);

        when(file.setReadable(true, true)).thenReturn(true);
        when(file.setWritable(true, true)).thenReturn(false); // força falha
        when(file.setExecutable(false, true)).thenReturn(true);

        assertDoesNotThrow(() -> ArquivoService.ajustarPermissoesPosCopia(path));

        verify(file).setReadable(true, true);
        verify(file).setWritable(true, true);
        verify(file).setExecutable(false, true);
        // Não precisamos checar log; a execução do bloco já está coberta
    }

    @Test
    void else_excecaoEhCapturada_noCatch() {
        org.junit.jupiter.api.Assumptions.assumeFalse(SystemUtils.IS_OS_UNIX);

        Path path = mock(Path.class);
        File file = mock(File.class);
        when(path.toFile()).thenReturn(file);

        when(file.setReadable(true, true)).thenThrow(new RuntimeException("boom"));

        assertDoesNotThrow(() -> ArquivoService.ajustarPermissoesPosCopia(path));

        // writable/executable podem não ser chamados por causa da exceção, então não verificamos
        verify(file).setReadable(true, true);
    }
}

-------------------------------------



package br.com.itau.app.services;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.io.TempDir;

import java.io.File;
import java.lang.reflect.Method;
import java.net.URL;
import java.net.URLClassLoader;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.Arrays;

/**
 * Força o ramo ELSE sem alterar a classe sob teste nem build.
 * Estratégia:
 *  1) Seta os.name = "Windows 10" (nesta thread/JVM).
 *  2) Cria um ClassLoader "child-first" isolado que carrega UMA NOVA cópia de:
 *     - org.apache.commons.lang3.SystemUtils
 *     - br.com.itau.app.services.ArquivoService
 *  3) Invoca o método estático via reflection passando um Path real.
 *
 * Assim, mesmo que SystemUtils já tenha sido inicializada na JVM principal,
 * dentro do classloader isolado ela será inicializada com "Windows 10"
 * e o código cairá no ELSE.
 */
public class ArquivoServiceElseOnlyTest {

    @Test
    void else_sucesso_comClassLoaderIsolado(@TempDir Path tempDir) throws Exception {
        // 1) Gera um arquivo real para passar ao método
        Path destino = tempDir.resolve("arquivo.txt");
        Files.writeString(destino, "teste");

        // 2) Força identificação de SO "Windows" ANTES de carregar as classes no ClassLoader isolado
        System.setProperty("os.name", "Windows 10");

        // 3) Monta um classpath com os mesmos caminhos da JVM atual
        URL[] urls = Arrays.stream(System.getProperty("java.class.path").split(File.pathSeparator))
                .map(p -> new File(p).toURI())
                .map(u -> {
                    try { return u.toURL(); } catch (Exception e) { throw new RuntimeException(e); }
                })
                .toArray(URL[]::new);

        // 4) ClassLoader "child-first": tenta este loader antes do pai
        try (URLClassLoader childFirst = new URLClassLoader(urls, /*parent*/ null) {
            private final ClassLoader appParent = ClassLoader.getSystemClassLoader();
            @Override
            protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {
                // Java core classes via parent (Path, Files, etc.)
                if (name.startsWith("java.") || name.startsWith("jdk.")) {
                    return super.loadClass(name, resolve);
                }
                // Tenta carregar primeiro por este loader (child-first)
                try {
                    Class<?> c = findLoadedClass(name);
                    if (c == null) c = findClass(name);
                    if (resolve) resolveClass(c);
                    return c;
                } catch (ClassNotFoundException e) {
                    // fallback: classes não encontradas, delega ao parent da aplicação
                    return appParent.loadClass(name);
                }
            }
        }) {
            // 5) Carrega uma NOVA cópia de SystemUtils e da sua classe no classloader isolado
            //    (mesmos nomes/pacotes da aplicação)
            Class<?> sysUtils = Class.forName("org.apache.commons.lang3.SystemUtils", true, childFirst);
            // sanity check opcional: garantir que essa cópia viu "Windows 10"
            boolean isUnixInIsolated = (boolean) sysUtils.getField("IS_OS_UNIX").get(null);
            if (isUnixInIsolated) {
                // Se por algum motivo ainda veio true, algo "vazou" no classpath
                throw new IllegalStateException("SystemUtils no classloader isolado não refletiu os.name=Windows 10");
            }

            Class<?> svc = Class.forName("br.com.itau.app.services.ArquivoService", true, childFirst);
            Method m = svc.getMethod("ajustarPermissoesPosCopia", Path.class);

            // 6) Invoca o método estático (cairá no ELSE dentro do classloader isolado)
            m.invoke(null, destino);

            // 7) Asserts best-effort no arquivo real
            File f = destino.toFile();
            // Leitura e escrita devem ter sido habilitadas no ELSE
            org.junit.jupiter.api.Assertions.assertTrue(f.canRead());
            org.junit.jupiter.api.Assertions.assertTrue(f.canWrite());
        }
    }
}


--------------------


package br.com.itau.app.services;

import org.junit.jupiter.api.Test;

import java.io.File;
import java.nio.file.Path;

import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;
import static org.mockito.Mockito.*;

class ArquivoServiceElseBranchTest {

    @Test
    void deveExecutarTodoElseEEntrarNoIfInterno() {
        // Arrange: mocka Path e File
        Path path = mock(Path.class);
        File file = mock(File.class);
        when(path.toFile()).thenReturn(file);

        // Configura permissões:
        // readable = true, writable = false (para cair no if interno), executable = true
        when(file.setReadable(true, true)).thenReturn(true);
        when(file.setWritable(true, true)).thenReturn(false); // força falha
        when(file.setExecutable(false, true)).thenReturn(true);

        // Act & Assert: chama o método, garantindo que não lança exceção
        assertDoesNotThrow(() -> ArquivoService.ajustarPermissoesPosCopia(path));

        // Verifica que os métodos foram invocados
        verify(file).setReadable(true, true);
        verify(file).setWritable(true, true);
        verify(file).setExecutable(false, true);
    }
}
