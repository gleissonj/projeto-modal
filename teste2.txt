import { TestBed } from '@angular/core/testing';
import { MyComponent } from './my-component'; // Replace with your actual component
import { MapValueMultipartUpload } from './map-value-multipart-upload.model'; // Replace with the correct model

describe('MyComponent', () => {
  let component: MyComponent;

  beforeEach(() => {
    TestBed.configureTestingModule({
      providers: [MyComponent],
    });

    component = TestBed.inject(MyComponent);
  });

  it('should call finishMultipartRequests for a single successful part', () => {
    // Arrange: Mock the mapMultipartUpload with one successful request part
    const mockFileParts: MapValueMultipartUpload[] = [
      { successfullRequest: true } as MapValueMultipartUpload
    ];

    const mapMultipartUpload = new Map<string, MapValueMultipartUpload[]>();
    mapMultipartUpload.set('mockHash', mockFileParts);

    component.mapMultipartUpload = mapMultipartUpload;
    const finishMultipartRequestsSpy = jest.spyOn(component, 'finishMultipartRequests');

    // Act: Call handleNextRequests
    component.handleNextRequests();

    // Assert: finishMultipartRequests should have been called
    expect(finishMultipartRequestsSpy).toHaveBeenCalledWith(mapMultipartUpload);
  });

  it('should skip parts that have unsuccessful requests', () => {
    // Arrange: Mock mapMultipartUpload with an unsuccessful request part
    const mockFileParts: MapValueMultipartUpload[] = [
      { successfullRequest: false } as MapValueMultipartUpload,
      { successfullRequest: true } as MapValueMultipartUpload
    ];

    const mapMultipartUpload = new Map<string, MapValueMultipartUpload[]>();
    mapMultipartUpload.set('mockHash', mockFileParts);

    component.mapMultipartUpload = mapMultipartUpload;
    const finishMultipartRequestsSpy = jest.spyOn(component, 'finishMultipartRequests');
    const asyncResquestsPartsSpy = jest.spyOn(component, 'asyncResquestsParts');

    // Act: Call handleNextRequests
    component.handleNextRequests();

    // Assert: It should skip the unsuccessful part and still proceed
    expect(finishMultipartRequestsSpy).not.toHaveBeenCalled();
    expect(asyncResquestsPartsSpy).toHaveBeenCalled();
  });

  it('should call asyncResquestsParts for remaining parts', () => {
    // Arrange: Mock mapMultipartUpload with multiple parts, some successful and some unsuccessful
    const mockFileParts: MapValueMultipartUpload[] = [
      { successfullRequest: true } as MapValueMultipartUpload,
      { successfullRequest: false } as MapValueMultipartUpload
    ];

    const mapMultipartUpload = new Map<string, MapValueMultipartUpload[]>();
    mapMultipartUpload.set('mockHash', mockFileParts);

    component.mapMultipartUpload = mapMultipartUpload;
    const asyncResquestsPartsSpy = jest.spyOn(component, 'asyncResquestsParts');

    // Act: Call handleNextRequests
    component.handleNextRequests();

    // Assert: asyncResquestsParts should have been called to continue handling other parts
    expect(asyncResquestsPartsSpy).toHaveBeenCalled();
  });
});
